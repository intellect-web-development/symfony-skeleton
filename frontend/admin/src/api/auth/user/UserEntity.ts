import {assignWithTypes} from "@/service/mutations";

export class UserEntity {
    id: string|null = '';
    createdAt: string|null = '';
    updatedAt: string|null = '';
    name: string|null = '';
    email: string|null = '';

    constructor(data?: any) {
        if (data) {
            this.mutate(data);
        }
    }

    public mutate(data: object) {
        assignWithTypes(data, this);
    }

    public isInit(): boolean
    {
        return this.id !== '';
    }
}

// todo: реализовать механизм типо доктрины, но на фронте, readonly. Похожая имплементация есть в ФабрикеКодогенератора.
//  суть в том, чтобы из одной сущности через геттеры можно было дотянуться до ее релейшенов, а внутри этих геттеров будут обращения в Store,
//  где хранятся вообще все скачанные сущности, такую store сделать общей, назвать EntityManagerStore, чтобы исключить огромное количество импортов.
//  При загрузке данных через read/search данные должны кэшироваться в этой Store, причем мутабельно, чтобы ссылки сохранялись на изначальные объекты.
//  Важно с точки зрения реализации, все геттеры которые работают со стораджем должны работать на Collection - объектах, которые передаются по ссылке,
//  чтобы в случае изменения состава этой коллекции на вьюхе они обновили реактивно.
//  Таким образом, чтобы это реализовать - каждая сущность должна будет реализовывать некоторый интерфейс, а именно:
//  {getSearchMethod, где будет передаваться метод нужной сторы, какой-то преднастроенный реквест, чтобы отфильтровать релейшены по ID этой сущности},
//  а геттеры уже будут автоматически реализовывать выполнение этих запросов, и сохранение их в сторе. А из сторы в этом геттере уже будут возвращаться
//  коллекции, которые будут отрисовываться. Чтобы стора тоже знала эти коллекции, и при повторном запросе могла их как-то кэшировать
//  можно задавать им уникальный ключ, и прям коллекции хранить отдельно в памяти этой сторы, пример формирования ключа: "{{entity.name}}.{{entityRelation.name}}"